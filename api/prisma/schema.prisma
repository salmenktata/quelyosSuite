generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Company {
  id     Int     @id @default(autoincrement())
  name   String
  isDemo Boolean @default(false)

  // Finance relations
  users                 User[]
  accounts              Account[]
  categories            Category[]                 @relation("CategoryCompany")
  budgets               Budgets[]
  portfolios            Portfolio[]
  planning              PlanningItem[]             @relation("CompanyToPlanningItem")
  planningBreakdowns    PlanningMonthlyBreakdown[] @relation("CompanyToPlanningMonthly")
  forecastEvents        ForecastEvent[]            @relation("ForecastEventCompany")
  forecastTrainingLogs  ForecastTrainingLog[]      @relation("CompanyForecastTraining")
  settings              CompanySettings?
  invitations           TeamInvitation[]
  auditLogs             AuditLog[]
  npsResponses          NPSResponse[]              @relation("CompanyNPS")
  cashAlerts            CashAlert[]                @relation("CompanyCashAlerts")
  budgetRecommendations BudgetRecommendation[]
  customers             Customer[]                 @relation("CompanyCustomers")

  // F92 - Supplier Management
  suppliers        Supplier[]        @relation("CompanySuppliers")
  supplierInvoices SupplierInvoice[] @relation("CompanySupplierInvoices")
  supplierPayments SupplierPayment[] @relation("CompanySupplierPayments")
  paymentScenarios PaymentScenario[] @relation("CompanyPaymentScenarios")

  // Marketing fields
  description           String?
  website               String?
  address               String?
  city                  String?
  postalCode            String?
  sector                Sector?
  sectorDetails         String?
  contentStyle          Style?
  marketingGoals        String[] @default([])
  stylePreferences      Json?
  publishingPreferences Json?

  // Marketing relations
  socialAccounts SocialAccount[]
  posts          Post[]
  inboxMessages  InboxMessage[]

  // Billing relations
  stripeCustomer StripeCustomer?
  subscriptions  Subscription[]
  invoices       Invoice[]

  // RH relations
  stores    Store[]    @relation("CompanyStores")
  teams     Team[]     @relation("CompanyTeams")
  employees Employee[] @relation("CompanyEmployees")
  contracts Contract[] @relation("CompanyContracts")
  documents Document[] @relation("CompanyDocuments")
  pointages Pointage[] @relation("CompanyPointages")
  demandes  Demande[]  @relation("CompanyDemandes")
  shifts    Shift[]    @relation("CompanyShifts")

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model User {
  id        Int     @id @default(autoincrement())
  email     String  @unique
  password  String
  role      Role    @default(USER)
  isDemo    Boolean @default(false)
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  // Profile fields (Marketing)
  firstName String?
  lastName  String?
  phone     String?

  // OAuth fields
  oauthProvider String? // "google" | "linkedin" | null
  oauthId       String? // ID from OAuth provider
  emailVerified Boolean @default(false)
  avatarUrl     String? // Profile picture from OAuth

  // 2FA fields
  twoFAEnabled Boolean @default(false)
  twoFASecret  String? // TOTP secret for 2FA

  // Currency preference
  displayCurrency String? // User's preferred display currency (null = use company default)

  // Finance relations
  resetTokens             PasswordResetToken[]
  refreshTokens           RefreshToken[]
  emailVerificationTokens EmailVerificationToken[]
  sentInvitations         TeamInvitation[]         @relation("InvitedBy")
  auditLogs               AuditLog[]               @relation("AuditUser")
  notificationPrefs       NotificationPreferences? @relation("NotificationPrefs")
  notifications           Notification[]           @relation("UserNotifications")
  npsResponses            NPSResponse[]            @relation("NPSResponses")
  cashAlerts              CashAlert[]              @relation("UserCashAlerts")
  categorySuggestions     CategorySuggestion[]     @relation("UserCategorySuggestions")

  // F92 - Supplier Management relations
  suppliersCreated Supplier[]        @relation("SupplierCreatedBy")
  paymentsCreated  SupplierPayment[] @relation("PaymentCreatedBy")
  scenariosCreated PaymentScenario[] @relation("ScenarioCreatedBy")

  // Marketing relations
  sessions Session[]

  // RH relations
  employee               Employee?       @relation("EmployeeUser")
  documentsUploaded      Document[]      @relation("DocumentUploader")
  shiftsCreated          Shift[]         @relation("ShiftCreatedBy")
  demandesApprovedByTeam Demande[]       @relation("DemandeApprovedByTeam")
  demandesApprovedByRH   Demande[]       @relation("DemandeApprovedByRH")
  demandesRejected       Demande[]       @relation("DemandeRejectedBy")
  shiftExchangesApproved ShiftExchange[] @relation("ShiftExchangeApprovedBy")
  shiftExchangesRejected ShiftExchange[] @relation("ShiftExchangeRejectedBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@unique([oauthProvider, oauthId])
}

model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
  ipAddress String?
  userAgent String?

  // Token rotation fields for enhanced security
  revokedAt  DateTime? // When the token was revoked
  replacedBy String? // Token that replaced this one (for rotation tracking)
  isUsed     Boolean   @default(false) // Track if token has been used for refresh

  @@index([userId])
  @@index([token])
  @@index([isUsed])
}

enum Role {
  ADMIN
  USER
  SUPERADMIN
  RH_ADMIN // Responsable RH
  RH_MANAGER // Responsable d'équipe
  RH_AGENT // Employé
}

enum AccountStatus {
  ACTIVE
  INACTIVE
}

enum PortfolioStatus {
  ACTIVE
  INACTIVE
}

// Types de flux de paiement
enum FlowType {
  CASH // Espèces
  CARD // Carte bancaire
  CHECK // Chèque
  TRANSFER // Virement
  DIRECT_DEBIT // Prélèvement
  BILL_OF_EXCHANGE // Traite / LCR
  PROMISSORY_NOTE // Billet à ordre
  BANK_CHARGE // Frais bancaires
  OTHER // Autre
}

model Account {
  id                  Int                  @id @default(autoincrement())
  name                String
  type                String               @default("banque")
  currency            String               @default("EUR")
  balance             Float                @default(0)
  institution         String?
  notes               String?
  isShared            Boolean              @default(false)
  status              AccountStatus        @default(ACTIVE)
  companyId           Int
  company             Company              @relation(fields: [companyId], references: [id])
  portfolioId         Int?
  portfolio           Portfolio?           @relation("AccountSinglePortfolio", fields: [portfolioId], references: [id])
  portfolios          AccountPortfolio[]
  transactions        Transaction[]
  paymentFlows        PaymentFlow[]
  duplicateDetections DuplicateDetection[] @relation("AccountDuplicateDetections")
}

// Flux de paiement (Cash, Carte, Chèque, Virement, Traite, etc.)
model PaymentFlow {
  id        Int     @id @default(autoincrement())
  accountId Int
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  type      FlowType @default(OTHER)
  name      String // Nom personnalisé (ex: "CB Visa Pro", "Chéquier 001")
  isActive  Boolean  @default(true)
  isDefault Boolean  @default(false)

  // Métadonnées optionnelles
  reference   String? // Numéro de carte, n° chéquier, etc.
  limitAmount Float? // Plafond (carte) ou encours max
  expiresAt   DateTime? // Date d'expiration (carte)
  color       String? // Couleur pour l'UI
  icon        String? // Icône personnalisée

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactions Transaction[]

  @@unique([accountId, type, reference])
  @@index([accountId])
}

model Transaction {
  id            Int               @id @default(autoincrement())
  amount        Float
  amountHT      Float             @default(0)
  amountTTC     Float             @default(0)
  vatRate       Float             @default(0)
  vatMode       String            @default("HT")
  type          String // "credit" | "debit"
  accountId     Int
  account       Account           @relation(fields: [accountId], references: [id])
  paymentFlowId Int?
  paymentFlow   PaymentFlow?      @relation(fields: [paymentFlowId], references: [id])
  occurredAt    DateTime          @default(now())
  scheduledFor  DateTime?
  status        TransactionStatus @default(CONFIRMED)
  description   String?
  archived      Boolean           @default(false)

  categoryId Int?
  category   Category? @relation("TransactionCategory", fields: [categoryId], references: [id])

  // ML Relations
  categorySuggestions CategorySuggestion[] @relation("TransactionSuggestions")
  duplicateDetections DuplicateDetection[] @relation("OriginalTransaction")
  anomaly             TransactionAnomaly?  @relation("TransactionAnomalies")
  customerInvoice     CustomerInvoice?     @relation("CustomerInvoiceTransaction")

  // F92 - Supplier Management
  supplierPayment SupplierPayment? @relation("TransactionSupplierPayment")

  @@index([paymentFlowId])
}

// Événements pour annotations sur les prévisions
model ForecastEvent {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation("ForecastEventCompany", fields: [companyId], references: [id], onDelete: Cascade)

  date        DateTime
  label       String
  description String?
  type        String   @default("manual") // "auto" | "manual" | "imported"

  // Metadata
  confidence Float? // 0.0-1.0 for auto-detected events
  source     String? // "recurring_detection" | "user" | "calendar_import"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId, date])
}

model ForecastTrainingLog {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation("CompanyForecastTraining", fields: [companyId], references: [id], onDelete: Cascade)

  trainedAt   DateTime @default(now())
  horizonDays Int // 7, 30, 90, or 180
  dataPoints  Int // Number of transactions used

  // Performance metrics
  mae           Float // Mean Absolute Error
  maePercentage Float // MAE as % of average balance
  rmse          Float // Root Mean Squared Error
  mape          Float // Mean Absolute Percentage Error
  coverage      Float // Confidence interval coverage (0-1)

  // Validation
  meetsTarget Boolean // Whether MAE < 10%

  @@index([companyId])
  @@index([trainedAt])
}

model Category {
  id            Int            @id @default(autoincrement())
  name          String
  kind          CategoryKind   @default(EXPENSE)
  companyId     Int
  company       Company        @relation("CategoryCompany", fields: [companyId], references: [id])
  transactions  Transaction[]  @relation("TransactionCategory")
  budgets       Budget[]
  budgetsList   Budgets[]
  planningItems PlanningItem[]

  // ML Relations
  suggestedFor          CategorySuggestion[]   @relation("SuggestedCategory")
  correctFor            CategorySuggestion[]   @relation("CorrectCategory")
  budgetRecommendations BudgetRecommendation[] @relation("BudgetRecommendations")

  createdAt DateTime @default(now())
}

enum CategoryKind {
  INCOME
  EXPENSE
}

enum PlanningType {
  INCOME
  EXPENSE
}

// Période de budget
enum BudgetPeriod {
  WEEKLY // Hebdomadaire
  BIWEEKLY // Bi-mensuel
  MONTHLY // Mensuel (défaut)
  QUARTERLY // Trimestriel
  YEARLY // Annuel
  CUSTOM // Personnalisé (avec date de fin)
}

// Statuts client (P5 - Credit Scoring)
enum CustomerStatus {
  ACTIVE
  SUSPENDED
  INACTIVE
}

// Statuts facture (P5 - Credit Scoring + F92 - Supplier Management)
enum InvoiceStatus {
  DRAFT
  SENT
  PENDING // En attente de paiement (F92)
  SCHEDULED // Paiement planifié (F92)
  OVERDUE
  PAID
  PARTIALLY_PAID
  PARTIAL // Partiellement payée (F92)
  CANCELED
  CANCELLED // Annulée (F92 - alias)
}

// Niveau de risque (P5 - Credit Scoring)
enum RiskLevel {
  LOW // 0-30
  MEDIUM // 31-60
  HIGH // 61-85
  CRITICAL // 86-100
}

// ====== F92 — Supplier Management Enums ======

enum SupplierCategory {
  STRATEGIC // Fournisseur stratégique (ex: AWS, fournisseur principal)
  REGULAR // Fournisseur récurrent
  OCCASIONAL // Fournisseur occasionnel
}

enum SupplierImportance {
  CRITICAL // Paiement prioritaire absolu
  HIGH // Haute priorité
  NORMAL // Priorité normale
  LOW // Peut être reporté
}

enum PaymentStrategy {
  BY_DUE_DATE // Par date d'échéance (défaut)
  BY_IMPORTANCE // Par importance fournisseur
  MINIMIZE_PENALTIES // Minimiser les pénalités
  MAXIMIZE_DISCOUNTS // Maximiser les remises
  OPTIMIZE_CASH_FLOW // Optimiser le cash flow global
}

model Budget {
  id       Int          @id @default(autoincrement())
  month    Int
  year     Int
  amount   Float
  period   BudgetPeriod @default(MONTHLY)
  startDay Int          @default(1) // Jour de début (1-28)

  categoryId Int
  category   Category @relation(fields: [categoryId], references: [id])
}

enum TransactionStatus {
  PLANNED
  CONFIRMED
  SCHEDULED
  CANCELED
}

model Budgets {
  id         Int          @id @default(autoincrement())
  name       String
  amount     Float? // Montant alloué
  categoryId Int? // Catégorie liée (optionnel)
  category   Category?    @relation(fields: [categoryId], references: [id])
  period     BudgetPeriod @default(MONTHLY)
  startDay   Int          @default(1) // Jour de réinitialisation (1-28)
  startDate  DateTime? // Date de début
  endDate    DateTime? // Date de fin (pour période CUSTOM)
  companyId  Int
  company    Company      @relation(fields: [companyId], references: [id])
  createdAt  DateTime     @default(now())

  // ML Relations
  recommendation BudgetRecommendation?
}

model BudgetRecommendation {
  id Int @id @default(autoincrement())

  budgetId Int?     @unique
  budget   Budgets? @relation(fields: [budgetId], references: [id])

  categoryId Int
  category   Category @relation("BudgetRecommendations", fields: [categoryId], references: [id])

  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  recommendedAmount Float
  confidence        Float // 0-100
  seasonalPattern   String // "stable" | "increasing" | "decreasing" | "seasonal"
  breakdown         Json // {min, q1, median, q3, max, avg, std}
  seasonalFactors   Json? // {monthly_amounts: {1: 920, 2: 850, ...}}
  analysisMonths    Int // 3-24

  createdAt  DateTime @default(now())
  validUntil DateTime // +7 days cache

  @@index([categoryId])
  @@index([companyId])
  @@index([validUntil])
}

model Portfolio {
  id             Int                @id @default(autoincrement())
  name           String
  description    String?
  status         PortfolioStatus    @default(ACTIVE)
  companyId      Int
  company        Company            @relation(fields: [companyId], references: [id])
  accounts       Account[]          @relation("AccountSinglePortfolio")
  sharedAccounts AccountPortfolio[]
  planningItems  PlanningItem[]
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
}

model AccountPortfolio {
  id          Int       @id @default(autoincrement())
  accountId   Int
  account     Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  portfolioId Int
  portfolio   Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())

  @@unique([accountId, portfolioId])
}

model PlanningItem {
  id               Int                        @id @default(autoincrement())
  label            String
  type             PlanningType               @default(EXPENSE)
  categoryId       Int?
  category         Category?                  @relation(fields: [categoryId], references: [id])
  portfolioId      Int?
  portfolio        Portfolio?                 @relation(fields: [portfolioId], references: [id])
  color            String?
  companyId        Int
  company          Company                    @relation("CompanyToPlanningItem", fields: [companyId], references: [id])
  archived         Boolean                    @default(false)
  createdAt        DateTime                   @default(now())
  updatedAt        DateTime                   @updatedAt
  monthlyBreakdown PlanningMonthlyBreakdown[]

  @@index([companyId])
  @@index([type])
}

model PlanningMonthlyBreakdown {
  id             Int          @id @default(autoincrement())
  planningItemId Int
  item           PlanningItem @relation(fields: [planningItemId], references: [id], onDelete: Cascade)
  month          String
  amount         Float
  companyId      Int
  company        Company      @relation("CompanyToPlanningMonthly", fields: [companyId], references: [id])
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@unique([planningItemId, month])
  @@index([companyId])
  @@index([month])
}

model PasswordResetToken {
  id               Int       @id @default(autoincrement())
  tokenHash        String    @unique
  userId           Int
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt        DateTime
  usedAt           DateTime?
  createdAt        DateTime  @default(now())
  createdIp        String?
  createdUserAgent String?

  @@index([userId])
  @@index([expiresAt])
}

// Token de vérification d'email
model EmailVerificationToken {
  id        Int       @id @default(autoincrement())
  tokenHash String    @unique
  userId    Int
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([expiresAt])
}

model CompanySettings {
  id             Int     @id @default(autoincrement())
  companyId      Int     @unique
  company        Company @relation(fields: [companyId], references: [id])
  vatActive      Boolean @default(false)
  vatMode        String  @default("HT")
  vatDefaultRate Float   @default(0)
  vatRates       Json?

  // Multi-currency settings
  baseCurrency    String    @default("EUR") // Company's reference currency for reporting
  autoUpdateRates Boolean   @default(true) // Auto-update exchange rates daily
  lastRateUpdate  DateTime? // Last time exchange rates were updated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ====== Multi-Currency Support ======

model ExchangeRate {
  id           Int      @id @default(autoincrement())
  fromCurrency String // Source currency code (ISO 4217: EUR, USD, GBP, etc.)
  toCurrency   String // Target currency code
  rate         Float // Exchange rate (1 fromCurrency = rate * toCurrency)
  date         DateTime @default(now()) // Date this rate is valid for
  source       String   @default("api") // Source of the rate (api, manual, etc.)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([fromCurrency, toCurrency, date])
  @@index([fromCurrency, toCurrency])
  @@index([date])
}

// ====== F54 — Gestion équipe avancée ======

model TeamInvitation {
  id          Int              @id @default(autoincrement())
  email       String
  companyId   Int
  company     Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  role        Role             @default(USER)
  token       String           @unique
  status      InvitationStatus @default(PENDING)
  invitedById Int
  invitedBy   User             @relation("InvitedBy", fields: [invitedById], references: [id])
  expiresAt   DateTime
  acceptedAt  DateTime?
  createdAt   DateTime         @default(now())

  @@index([companyId])
  @@index([email])
  @@index([token])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

model AuditLog {
  id          Int      @id @default(autoincrement())
  companyId   Int
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  userId      Int?
  user        User?    @relation("AuditUser", fields: [userId], references: [id], onDelete: SetNull)
  action      String // CREATE_USER, DELETE_USER, CHANGE_ROLE, INVITE_MEMBER, etc.
  targetType  String // User, Account, Transaction, Budget, etc.
  targetId    Int?
  targetEmail String? // Pour les invitations (email du membre invité)
  metadata    Json? // Détails supplémentaires (oldRole, newRole, etc.)
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([companyId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
}

// ====== F44 — Notifications push/email ======

model NotificationPreferences {
  id     Int  @id @default(autoincrement())
  userId Int  @unique
  user   User @relation("NotificationPrefs", fields: [userId], references: [id], onDelete: Cascade)

  // Email notifications
  emailOnTransaction    Boolean @default(false)
  emailOnBudgetAlert    Boolean @default(true)
  emailOnExpenseWarning Boolean @default(true)
  weeklyDigest          Boolean @default(true)
  monthlyReport         Boolean @default(true)

  // Push notifications (future)
  pushEnabled       Boolean @default(false)
  pushOnTransaction Boolean @default(false)
  pushOnBudgetAlert Boolean @default(true)

  // Thresholds
  budgetAlertThreshold Int @default(80) // Percentage

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Notification {
  id        Int              @id @default(autoincrement())
  userId    Int
  user      User             @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String
  actionUrl String?
  read      Boolean          @default(false)
  sentEmail Boolean          @default(false)
  sentPush  Boolean          @default(false)
  metadata  Json?
  createdAt DateTime         @default(now())
  readAt    DateTime?

  @@index([userId])
  @@index([read])
  @@index([createdAt])
}

enum NotificationType {
  BUDGET_ALERT // Budget > 80%
  BUDGET_EXCEEDED // Budget > 100%
  EXPENSE_WARNING // Dépense anormale
  INVOICE_REMINDER // Rappel facture
  WEEKLY_DIGEST // Résumé hebdo
  MONTHLY_REPORT // Rapport mensuel
  TEAM_INVITE // Invitation équipe
  SYSTEM // Notifications système
  CASH_ALERT // Alerte trésorerie
  TRANSACTION // Transaction notification
}

// ====== F93 — Alertes Trésorerie ======

enum CashAlertType {
  THRESHOLD // Solde < seuil
  NEGATIVE_FORECAST // Prévision négative 30/60/90j
  VARIANCE // Écart >X% vs prévisions
}

model CashAlert {
  id        Int     @id @default(autoincrement())
  userId    Int
  user      User    @relation("UserCashAlerts", fields: [userId], references: [id], onDelete: Cascade)
  companyId Int
  company   Company @relation("CompanyCashAlerts", fields: [companyId], references: [id], onDelete: Cascade)

  name     String // "Alerte seuil critique"
  isActive Boolean @default(true)

  // Types d'alerte
  type CashAlertType // THRESHOLD | NEGATIVE_FORECAST | VARIANCE

  // Conditions (JSON flexible)
  thresholdAmount Float? // Seuil montant (ex: 5000€)
  horizonDays     Int? // Horizon prévision (30/60/90)
  compareOperator String? // "lt" | "lte" | "gt" | "gte"

  // Notifications
  emailEnabled    Boolean  @default(true)
  emailRecipients String[] @default([]) // Emails additionnels

  // Cooldown anti-spam
  cooldownHours Int @default(24) // 1 alerte max par 24h

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  triggers AlertTrigger[]

  @@index([userId])
  @@index([companyId])
  @@index([isActive])
}

model AlertTrigger {
  id      Int       @id @default(autoincrement())
  alertId Int
  alert   CashAlert @relation(fields: [alertId], references: [id], onDelete: Cascade)

  triggeredAt DateTime @default(now())
  value       Float // Valeur qui a déclenché (ex: solde = 3450€)
  context     Json? // Metadata (horizon, scénario, etc.)

  emailSent   Boolean   @default(false)
  emailSentAt DateTime?

  @@index([alertId])
  @@index([triggeredAt])
}

// NPS Feedback - Net Promoter Score
model NPSResponse {
  id               Int      @id @default(autoincrement())
  userId           Int
  user             User     @relation("NPSResponses", fields: [userId], references: [id], onDelete: Cascade)
  companyId        Int
  company          Company  @relation("CompanyNPS", fields: [companyId], references: [id], onDelete: Cascade)
  score            Int // 0-10
  feedback         String? // Optional text feedback
  testimonialOptIn Boolean  @default(false) // User accepts to be contacted for testimonial
  createdAt        DateTime @default(now())

  @@index([userId])
  @@index([companyId])
  @@index([score])
  @@index([createdAt])
}

// ============================================
// MARKETING MODULE
// ============================================

enum Sector {
  RESTAURANT
  COMMERCE_PROXIMITE
  ARTISAN
  BEAUTE_BIEN_ETRE
  COIFFURE
  COACH
  COMMERCE
  SERVICE
  AUTRES
  OTHER
}

enum Style {
  PROFESSIONAL
  PROFESSIONNEL
  CASUAL
  DECONTRACTE
  HUMOROUS
  HUMORISTIQUE
  INSPIRATIONAL
  INSPIRANT
  EDUCATIF
}

enum Platform {
  INSTAGRAM
  FACEBOOK
  GOOGLE_BUSINESS
  TIKTOK
  LINKEDIN
}

enum MediaType {
  IMAGE
  VIDEO
  CAROUSEL
}

enum PostStatus {
  DRAFT
  SCHEDULED
  PUBLISHING
  PUBLISHED
  FAILED
}

enum PublicationStatus {
  PENDING
  SUCCESS
  FAILED
}

enum MessageType {
  COMMENT
  DIRECT_MESSAGE
  MENTION
  REVIEW
}

model SocialAccount {
  id           Int               @id @default(autoincrement())
  platform     Platform
  accountId    String
  accountName  String
  accessToken  String
  refreshToken String?
  expiresAt    DateTime?
  companyId    Int
  company      Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  posts        PostPublication[]
  createdAt    DateTime          @default(now())

  @@unique([platform, accountId])
  @@index([companyId])
}

model Post {
  id           Int               @id @default(autoincrement())
  content      String            @db.Text
  hashtags     String[]          @default([])
  mediaUrl     String?
  mediaType    MediaType?
  status       PostStatus        @default(DRAFT)
  scheduledAt  DateTime?
  publishedAt  DateTime?
  starred      Boolean           @default(false)
  internalNote String?
  companyId    Int
  company      Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  publications PostPublication[]
  analytics    PostAnalytics?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@index([companyId])
  @@index([companyId, status])
}

model PostPublication {
  id              Int               @id @default(autoincrement())
  postId          Int
  post            Post              @relation(fields: [postId], references: [id], onDelete: Cascade)
  socialAccountId Int
  socialAccount   SocialAccount     @relation(fields: [socialAccountId], references: [id], onDelete: Cascade)
  externalId      String?
  status          PublicationStatus @default(PENDING)
  error           String?
  publishedAt     DateTime?
  createdAt       DateTime          @default(now())

  @@index([postId])
  @@index([socialAccountId])
}

model PostAnalytics {
  id          Int      @id @default(autoincrement())
  postId      Int      @unique
  post        Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  impressions Int      @default(0)
  reach       Int      @default(0)
  likes       Int      @default(0)
  comments    Int      @default(0)
  shares      Int      @default(0)
  saves       Int      @default(0)
  clicks      Int      @default(0)
  updatedAt   DateTime @updatedAt
}

model InboxMessage {
  id              Int         @id @default(autoincrement())
  platform        Platform
  externalId      String
  type            MessageType
  authorName      String
  authorAvatar    String?
  content         String      @db.Text
  postId          String?
  isRead          Boolean     @default(false)
  repliedAt       DateTime?
  internalComment String?
  companyId       Int
  company         Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdAt       DateTime    @default(now())

  @@index([companyId, isRead])
  @@index([platform, externalId])
}

model Waitlist {
  id           String   @id @default(uuid())
  email        String   @unique
  name         String?
  businessType String?
  source       String   @default("landing")
  createdAt    DateTime @default(now())

  @@index([createdAt])
}

model Session {
  id        Int       @id @default(autoincrement())
  tokenId   String    @unique
  tokenHash String
  userId    Int
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userAgent String?
  ip        String?
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())

  @@index([userId])
}

// ═══════════════════════════════════════════════════════════════════════════
// BILLING & SUBSCRIPTIONS (STRIPE)
// ═══════════════════════════════════════════════════════════════════════════

enum SubscriptionPlan {
  FREE
  PRO
  EXPERT
}

enum SubscriptionStatus {
  ACTIVE
  TRIALING
  PAST_DUE
  CANCELED
  INCOMPLETE
  INCOMPLETE_EXPIRED
  UNPAID
}

model StripeCustomer {
  id               Int            @id @default(autoincrement())
  companyId        Int            @unique
  company          Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  stripeCustomerId String         @unique
  email            String?
  name             String?
  subscriptions    Subscription[]
  invoices         Invoice[]
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([stripeCustomerId])
}

model Subscription {
  id                   Int                @id @default(autoincrement())
  companyId            Int
  company              Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  stripeCustomerId     Int
  stripeCustomer       StripeCustomer     @relation(fields: [stripeCustomerId], references: [id], onDelete: Cascade)
  stripeSubscriptionId String             @unique
  plan                 SubscriptionPlan   @default(FREE)
  status               SubscriptionStatus @default(ACTIVE)

  // Pricing
  priceId  String? // Stripe Price ID
  amount   Int? // Amount in cents (e.g., 1900 for 19€)
  currency String  @default("eur")
  interval String? // "month" | "year"

  // Trial
  trialStart DateTime?
  trialEnd   DateTime?

  // Billing
  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  cancelAtPeriodEnd  Boolean   @default(false)
  canceledAt         DateTime?
  endedAt            DateTime?

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([stripeSubscriptionId])
  @@index([status])
}

model Invoice {
  id               Int            @id @default(autoincrement())
  companyId        Int
  company          Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  stripeCustomerId Int
  stripeCustomer   StripeCustomer @relation(fields: [stripeCustomerId], references: [id], onDelete: Cascade)
  stripeInvoiceId  String         @unique

  // Invoice details
  number     String?
  amountDue  Int // Amount in cents
  amountPaid Int     @default(0)
  currency   String  @default("eur")
  status     String // "draft" | "open" | "paid" | "uncollectible" | "void"

  // Links
  hostedInvoiceUrl String? @db.Text
  invoicePdf       String? @db.Text

  // Dates
  dueDate DateTime?
  paidAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([stripeInvoiceId])
  @@index([status])
}

// ====== Payment Provider Configuration (Super Admin) ======

enum PaymentProvider {
  STRIPE
  PAYPAL
}

model PaymentProviderConfig {
  id        Int             @id @default(autoincrement())
  provider  PaymentProvider @unique
  isEnabled Boolean         @default(false)

  // API Credentials (encrypted/hashed in production)
  publicKey     String? @db.Text // Stripe publishable key / PayPal client ID
  secretKey     String? @db.Text // Stripe secret key / PayPal secret (encrypted)
  webhookSecret String? @db.Text // Webhook signing secret

  // Configuration
  mode     String @default("test") // "test" | "production"
  currency String @default("EUR") // Default currency

  // Additional settings (provider-specific)
  config Json? // Extra configuration as JSON

  // Metadata
  lastTestedAt DateTime? // Last time credentials were verified
  testResult   String? // "success" | "failed"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([provider])
  @@index([isEnabled])
}

model EmailProviderConfig {
  id        Int     @id @default(autoincrement())
  provider  String  @default("BREVO") // BREVO (Sendinblue), SENDGRID, etc.
  isEnabled Boolean @default(false)

  // API Credentials (encrypted in production)
  apiKey String? @db.Text // Brevo API key (xkeysib-...)

  // Sender Configuration
  senderEmail String? // Email address (must be verified in provider)
  senderName  String? // Display name in emails

  // Configuration
  mode String @default("production") // "test" | "production"

  // Metadata
  lastTestedAt DateTime? // Last time credentials were verified
  testResult   String? // "success" | "failed"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isEnabled])
}

// ═══════════════════════════════════════════════════════════════════════════
// ML CATEGORIZATION
// ═══════════════════════════════════════════════════════════════════════════

model CategorySuggestion {
  id Int @id @default(autoincrement())

  // Transaction concernée
  transactionId Int
  transaction   Transaction @relation("TransactionSuggestions", fields: [transactionId], references: [id], onDelete: Cascade)

  // Suggestion ML
  suggestedCategoryId Int
  suggestedCategory   Category @relation("SuggestedCategory", fields: [suggestedCategoryId], references: [id])

  confidence Float // 0.0-1.0

  // Feedback utilisateur
  accepted Boolean // true = acceptée, false = rejetée

  correctCategoryId Int? // Si rejetée, quelle était la bonne catégorie
  correctCategory   Category? @relation("CorrectCategory", fields: [correctCategoryId], references: [id])

  // Audit
  userId Int
  user   User @relation("UserCategorySuggestions", fields: [userId], references: [id])

  createdAt DateTime @default(now())

  @@index([transactionId])
  @@index([suggestedCategoryId])
  @@index([accepted])
  @@index([createdAt])
}

// ═══════════════════════════════════════════════════════════════════════════
// ML DUPLICATE DETECTION
// ═══════════════════════════════════════════════════════════════════════════

model DuplicateDetection {
  id Int @id @default(autoincrement())

  accountId Int
  account   Account @relation("AccountDuplicateDetections", fields: [accountId], references: [id], onDelete: Cascade)

  // Transaction originale détectée comme doublon
  originalTransactionId Int
  originalTransaction   Transaction @relation("OriginalTransaction", fields: [originalTransactionId], references: [id], onDelete: Cascade)

  // Données de la nouvelle transaction (non créée si doublon confirmé)
  description String?
  amount      Float
  occurredAt  DateTime

  // Scoring
  similarityScore Float // 0.0-1.0

  // Statut
  status String @default("PENDING") // PENDING | CONFIRMED_DUPLICATE | IGNORED

  createdAt DateTime @default(now())

  @@index([accountId])
  @@index([originalTransactionId])
  @@index([status])
  @@index([createdAt])
}

// ═══════════════════════════════════════════════════════════════════════════
// ML ANOMALY DETECTION
// ═══════════════════════════════════════════════════════════════════════════

model TransactionAnomaly {
  id Int @id @default(autoincrement())

  transactionId Int         @unique
  transaction   Transaction @relation("TransactionAnomalies", fields: [transactionId], references: [id], onDelete: Cascade)

  score       Float // 0.0-1.0
  severity    String // "low" | "medium" | "high"
  explanation String @db.Text

  dismissed Boolean @default(false) // User dismissed alert

  createdAt DateTime @default(now())

  @@index([transactionId])
  @@index([severity])
  @@index([dismissed])
  @@index([createdAt])
}

// ═══════════════════════════════════════════════════════════════════════════
// P5 - CREDIT SCORING INFRASTRUCTURE
// ═══════════════════════════════════════════════════════════════════════════

model Customer {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation("CompanyCustomers", fields: [companyId], references: [id])

  // Informations client
  name    String
  email   String?
  phone   String?
  legalId String? // SIRET/SIREN
  address String?

  // Conditions paiement
  status       CustomerStatus @default(ACTIVE)
  paymentTerms Int            @default(30) // Jours (Net 30, Net 60)
  creditLimit  Float?

  // Relations
  invoices   CustomerInvoice[]
  riskScores CustomerRiskScore[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([status])
}

model CustomerInvoice {
  id         Int      @id @default(autoincrement())
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id])

  invoiceNumber String  @unique
  reference     String?

  amount          Float
  amountPaid      Float  @default(0)
  amountRemaining Float  @default(0)
  currency        String @default("EUR")

  issuedDate DateTime  @default(now())
  dueDate    DateTime
  paidDate   DateTime?

  status       InvoiceStatus @default(DRAFT)
  paymentDelay Int? // Jours de retard (+) ou avance (-)

  transactionId Int?         @unique
  transaction   Transaction? @relation("CustomerInvoiceTransaction", fields: [transactionId], references: [id])

  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([customerId])
  @@index([status])
  @@index([dueDate])
}

model CustomerRiskScore {
  id         Int      @id @default(autoincrement())
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id])

  score          Float // 0-100
  riskLevel      RiskLevel
  predictedDelay Int? // Jours
  confidence     Float

  features       Json // {avgDelay, lateRate, relationshipMonths, ...}
  recommendation String?

  modelVersion String   @default("1.0")
  createdAt    DateTime @default(now())
  validUntil   DateTime // +1 mois

  @@index([customerId])
  @@index([riskLevel])
  @@index([validUntil])
}

// ═══════════════════════════════════════════════════════════════════════════
// F92 - SUPPLIER MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════

model Supplier {
  id        String  @id @default(cuid())
  companyId Int
  company   Company @relation("CompanySuppliers", fields: [companyId], references: [id], onDelete: Cascade)

  // Informations de base
  name    String
  email   String?
  phone   String?
  website String?

  // Informations bancaires
  iban String?
  bic  String?

  // Catégorisation
  category   SupplierCategory   @default(REGULAR)
  importance SupplierImportance @default(NORMAL)

  // Conditions de paiement
  defaultPaymentDelay  Int    @default(30) // jours
  latePaymentPenalty   Float? // % par jour de retard
  earlyPaymentDiscount Float? // % si paiement anticipé

  // Métadonnées
  notes String?
  tags  String[] // ["stratégique", "IT", "marketing"]

  // Relations
  invoices SupplierInvoice[]
  payments SupplierPayment[]

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy Int?
  user      User?    @relation("SupplierCreatedBy", fields: [createdBy], references: [id])

  @@index([companyId])
  @@index([category])
  @@index([importance])
}

model SupplierInvoice {
  id        String  @id @default(cuid())
  companyId Int
  company   Company @relation("CompanySupplierInvoices", fields: [companyId], references: [id], onDelete: Cascade)

  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  // Informations facture
  invoiceNumber String
  invoiceDate   DateTime
  dueDate       DateTime
  amount        Float
  currency      String   @default("EUR")

  // Description
  description String?
  category    String? // "IT", "Marketing", "Office supplies"

  // Statut paiement
  status     InvoiceStatus @default(PENDING)
  paidAt     DateTime?
  paidAmount Float?

  // Calculs automatiques
  paymentDelay  Int // calculé: dueDate - invoiceDate
  daysOverdue   Int    @default(0) // calculé si OVERDUE
  penaltyAmount Float? // calculé si retard

  // Pièces jointes
  attachmentUrl String?

  // Relations
  payments  SupplierPayment[]
  scenarios PaymentScenario[] @relation("ScenarioInvoices")

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, invoiceNumber])
  @@index([companyId, supplierId])
  @@index([status])
  @@index([dueDate])
}

model SupplierPayment {
  id        String  @id @default(cuid())
  companyId Int
  company   Company @relation("CompanySupplierPayments", fields: [companyId], references: [id], onDelete: Cascade)

  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id])

  invoiceId String?
  invoice   SupplierInvoice? @relation(fields: [invoiceId], references: [id])

  // Paiement
  amount        Float
  paymentDate   DateTime
  paymentMethod String   @default("VIREMENT") // VIREMENT, CHEQUE, CARTE
  reference     String?

  // Relation avec Transaction
  transactionId Int?         @unique
  transaction   Transaction? @relation("TransactionSupplierPayment", fields: [transactionId], references: [id])

  // Audit
  createdAt DateTime @default(now())
  createdBy Int?
  user      User?    @relation("PaymentCreatedBy", fields: [createdBy], references: [id])

  @@index([companyId, supplierId])
  @@index([paymentDate])
}

model PaymentScenario {
  id        String  @id @default(cuid())
  companyId Int
  company   Company @relation("CompanyPaymentScenarios", fields: [companyId], references: [id], onDelete: Cascade)

  // Informations du scénario
  name        String
  description String?

  // Stratégie de paiement
  strategy          PaymentStrategy @default(BY_DUE_DATE)
  maxDailyAmount    Float? // limite journalière
  targetCashReserve Float? // réserve de trésorerie à maintenir

  // Factures incluses dans le scénario
  invoices SupplierInvoice[] @relation("ScenarioInvoices")

  // Résultats de simulation
  totalAmount       Float
  startDate         DateTime
  endDate           DateTime
  projectedCashFlow Json? // Résultat de la simulation Prophet

  // Métriques
  totalPenalties Float  @default(0)
  totalDiscounts Float  @default(0)
  riskScore      Float? // 0-100, risque de découvert

  // État
  isActive  Boolean   @default(false)
  appliedAt DateTime?

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy Int?
  user      User?    @relation("ScenarioCreatedBy", fields: [createdBy], references: [id])

  @@index([companyId])
  @@index([isActive])
}

// ═══════════════════════════════════════════════════════════════════════════
// MODULE RH (RESSOURCES HUMAINES)
// ═══════════════════════════════════════════════════════════════════════════

// Enums RH
enum EmployeeStatus {
  ACTIVE // Actif
  ON_LEAVE // En congé
  SUSPENDED // Suspendu
  TERMINATED // Contrat terminé
}

enum ContractType {
  CDI // Contrat à durée indéterminée
  CDD // Contrat à durée déterminée
  INTERIM // Intérim
  STAGE // Stage
  ALTERNANCE // Alternance
  FREELANCE // Freelance
}

enum DemandeType {
  CONGES // Congés payés
  ABSENCE // Absence (maladie, etc.)
  AVANCE // Avance sur salaire
}

enum DemandeStatus {
  PENDING // En attente
  APPROVED_TEAM // Validé par responsable équipe
  APPROVED_RH // Validé par RH (final)
  REJECTED // Refusé
  CANCELLED // Annulé par l'employé
}

enum PointageType {
  ENTREE // Entrée
  SORTIE // Sortie
}

enum PointageStatus {
  VALID // Validé
  PENDING // En attente sync offline
  LATE // Retard
  ANOMALY // Anomalie détectée
  MISSING_OUT // Sortie manquante
}

enum ShiftStatus {
  SCHEDULED // Planifié
  CONFIRMED // Confirmé
  COMPLETED // Terminé
  CANCELLED // Annulé
  ABSENT // Absent
}

enum DocumentType {
  CONTRACT // Contrat de travail
  AMENDMENT // Avenant
  PAY_SLIP // Bulletin de paie
  ID_CARD // CIN/Passeport
  CERTIFICATE // Certificat
  JUSTIFICATION // Justificatif (congé, etc.)
  OTHER // Autre
}

enum DocumentVisibility {
  EMPLOYEE // Visible par l'employé
  RH_ONLY // Visible uniquement par RH
  ADMIN_ONLY // Visible uniquement par admin
}

// Magasins / Points de vente
model Store {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation("CompanyStores", fields: [companyId], references: [id], onDelete: Cascade)

  name       String
  code       String  @unique // Code unique magasin (ex: "MAG001")
  address    String?
  city       String?
  postalCode String?
  phone      String?

  // Géolocalisation pour validation GPS pointage
  latitude     Float?
  longitude    Float?
  radiusMeters Int    @default(100) // Rayon de validation GPS (mètres)

  // QR Code statique pour pointage
  qrCodeData   String @unique // Données du QR code
  qrCodeSecret String // Secret pour validation

  // Manager du magasin
  managerId Int?
  manager   Employee? @relation("StoreManager", fields: [managerId], references: [id], onDelete: SetNull)

  isActive Boolean @default(true)

  // Relations
  teams     Team[]
  employees Employee[] @relation("StoreEmployees")
  pointages Pointage[]
  shifts    Shift[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([managerId])
  @@index([qrCodeData])
}

// Équipes de travail
model Team {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation("CompanyTeams", fields: [companyId], references: [id], onDelete: Cascade)

  storeId Int?
  store   Store? @relation(fields: [storeId], references: [id], onDelete: SetNull)

  name        String
  description String?

  // Responsable d'équipe
  managerId Int?
  manager   Employee? @relation("TeamManager", fields: [managerId], references: [id], onDelete: SetNull)

  isActive Boolean @default(true)

  // Relations
  employees Employee[] @relation("TeamEmployees")
  shifts    Shift[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([storeId])
  @@index([managerId])
}

// Employés
model Employee {
  id        Int     @id @default(autoincrement())
  companyId Int
  company   Company @relation("CompanyEmployees", fields: [companyId], references: [id], onDelete: Cascade)

  // Lien avec User (optionnel - tous les employés n'ont pas forcément un compte)
  userId Int?  @unique
  user   User? @relation("EmployeeUser", fields: [userId], references: [id], onDelete: SetNull)

  // Informations personnelles
  employeeNumber String    @unique // Matricule unique
  firstName      String
  lastName       String
  email          String?
  phone          String?
  dateOfBirth    DateTime?
  address        String?
  city           String?
  postalCode     String?

  // CIN/Passeport
  cinNumber     String?
  cinExpiryDate DateTime?

  // Informations professionnelles
  storeId Int?
  store   Store? @relation("StoreEmployees", fields: [storeId], references: [id], onDelete: SetNull)

  teamId Int?
  team   Team? @relation("TeamEmployees", fields: [teamId], references: [id], onDelete: SetNull)

  position String? // Poste (Vendeur, Caissier, etc.)
  hireDate DateTime // Date d'embauche
  status   EmployeeStatus @default(ACTIVE)

  // Responsable hiérarchique
  managerId    Int?
  manager      Employee?  @relation("EmployeeManager", fields: [managerId], references: [id], onDelete: SetNull)
  subordinates Employee[] @relation("EmployeeManager")

  // Paramètres de paie
  baseSalary  Float? // Salaire de base
  bankAccount String? // RIB

  // Paramètres de congés
  leaveBalance Float @default(0) // Solde de congés payés (jours)
  leaveTaken   Float @default(0) // Congés pris cette année

  // QR Code pour pointage
  qrCode String @unique // Token unique pour QR code

  // Relations
  contracts      Contract[]
  documents      Document[]
  pointages      Pointage[]
  demandes       Demande[]
  shifts         Shift[]
  shiftExchanges ShiftExchange[]

  // Relations "manager de"
  managedStores Store[] @relation("StoreManager")
  managedTeams  Team[]  @relation("TeamManager")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, employeeNumber])
  @@index([companyId])
  @@index([userId])
  @@index([storeId])
  @@index([teamId])
  @@index([managerId])
  @@index([status])
  @@index([qrCode])
}

// Contrats de travail
model Contract {
  id         Int      @id @default(autoincrement())
  companyId  Int
  company    Company  @relation("CompanyContracts", fields: [companyId], references: [id], onDelete: Cascade)
  employeeId Int
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  contractType ContractType
  startDate    DateTime
  endDate      DateTime? // Null pour CDI
  position     String
  salary       Float
  workingHours Float        @default(35) // Heures hebdomadaires

  // Document du contrat (stocké en S3/MinIO)
  documentUrl String?
  documentKey String? // Clé S3

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([employeeId])
  @@index([isActive])
}

// Documents RH
model Document {
  id         Int      @id @default(autoincrement())
  companyId  Int
  company    Company  @relation("CompanyDocuments", fields: [companyId], references: [id], onDelete: Cascade)
  employeeId Int
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  type        DocumentType
  title       String
  description String?

  // Stockage S3/MinIO
  fileUrl  String // URL signée temporaire (générée à la demande)
  fileKey  String // Clé unique dans S3
  fileName String // Nom original du fichier
  fileSize Int // Taille en bytes
  mimeType String

  // Sécurité
  visibility      DocumentVisibility @default(EMPLOYEE)
  virusScanned    Boolean            @default(false)
  virusScanResult String? // Résultat du scan ClamAV

  // Metadata
  uploadedById Int
  uploadedBy   User @relation("DocumentUploader", fields: [uploadedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([employeeId])
  @@index([type])
  @@index([uploadedById])
}

// Pointages (Check-in/out)
model Pointage {
  id         Int      @id @default(autoincrement())
  companyId  Int
  company    Company  @relation("CompanyPointages", fields: [companyId], references: [id], onDelete: Cascade)
  employeeId Int
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  storeId    Int?
  store      Store?   @relation(fields: [storeId], references: [id], onDelete: SetNull)

  type      PointageType
  status    PointageStatus @default(VALID)
  timestamp DateTime       @default(now())

  // Géolocalisation
  latitude  Float?
  longitude Float?
  accuracy  Float? // Précision GPS (mètres)

  // QR Code validation
  qrCodeScanned String?

  // Device info
  deviceId    String?
  deviceModel String?
  appVersion  String?

  // Offline sync
  syncedAt        DateTime?
  clientTimestamp DateTime? // Timestamp original du device

  // Anomalie detection
  isAnomaly     Boolean @default(false)
  anomalyReason String? // "geolocation_mismatch", "duplicate", "timing_issue"

  // Validation manuelle
  validatedBy     Int?
  validatedAt     DateTime?
  justification   String?
  rejectionReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([employeeId])
  @@index([storeId])
  @@index([timestamp])
  @@index([status])
  @@index([isAnomaly])
}

// Demandes (Congés, Absences, Avances)
model Demande {
  id         Int      @id @default(autoincrement())
  companyId  Int
  company    Company  @relation("CompanyDemandes", fields: [companyId], references: [id], onDelete: Cascade)
  employeeId Int
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  type   DemandeType
  status DemandeStatus @default(PENDING)

  // Date range (pour congés/absences)
  startDate DateTime?
  endDate   DateTime?
  daysCount Float? // Nombre de jours calculés

  // Montant (pour avances)
  amount Float?

  // Justification
  reason           String?
  justificationUrl String? // URL fichier uploadé (S3)
  justificationKey String? // Clé S3

  // Workflow approbation niveau 1 (Responsable équipe)
  approvedByTeamId Int?
  approvedByTeam   User?     @relation("DemandeApprovedByTeam", fields: [approvedByTeamId], references: [id], onDelete: SetNull)
  teamApprovedAt   DateTime?

  // Workflow approbation niveau 2 (RH - final)
  approvedByRhId Int?
  approvedByRh   User?     @relation("DemandeApprovedByRH", fields: [approvedByRhId], references: [id], onDelete: SetNull)
  rhApprovedAt   DateTime?

  // Rejet
  rejectedById    Int?
  rejectedBy      User?     @relation("DemandeRejectedBy", fields: [rejectedById], references: [id], onDelete: SetNull)
  rejectionReason String?
  rejectedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([employeeId])
  @@index([status])
  @@index([type])
  @@index([startDate])
}

// Planning (Shifts)
model Shift {
  id         Int      @id @default(autoincrement())
  companyId  Int
  company    Company  @relation("CompanyShifts", fields: [companyId], references: [id], onDelete: Cascade)
  employeeId Int
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  storeId Int?
  store   Store? @relation(fields: [storeId], references: [id], onDelete: SetNull)

  teamId Int?
  team   Team? @relation(fields: [teamId], references: [id], onDelete: SetNull)

  // Horaires
  startTime DateTime
  endTime   DateTime

  // Position/Poste pour ce shift
  position String?

  // Statut
  status ShiftStatus @default(SCHEDULED)

  // Pause (minutes)
  breakDuration Int @default(0)

  // Notes
  notes String?

  // Création
  createdById Int
  createdBy   User @relation("ShiftCreatedBy", fields: [createdById], references: [id])

  // Relations
  exchanges ShiftExchange[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([employeeId])
  @@index([storeId])
  @@index([teamId])
  @@index([startTime])
  @@index([status])
}

// Échanges de shifts entre employés
model ShiftExchange {
  id      Int   @id @default(autoincrement())
  shiftId Int
  shift   Shift @relation(fields: [shiftId], references: [id], onDelete: Cascade)

  requesterId Int
  requester   Employee @relation(fields: [requesterId], references: [id], onDelete: Cascade)

  receiverId Int? // Employé qui reprend le shift (optionnel au départ)
  reason     String?

  status String @default("PENDING") // PENDING | APPROVED | REJECTED | CANCELLED

  // Approbation
  approvedById    Int?
  approvedBy      User?     @relation("ShiftExchangeApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)
  approvedAt      DateTime?
  rejectedById    Int?
  rejectedBy      User?     @relation("ShiftExchangeRejectedBy", fields: [rejectedById], references: [id], onDelete: SetNull)
  rejectionReason String?
  rejectedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([shiftId])
  @@index([requesterId])
  @@index([status])
}

// Paramètres système pour configuration ML et autres
model SystemParameter {
  id          Int      @id @default(autoincrement())
  key         String   @unique
  value       String
  description String?
  category    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
}
